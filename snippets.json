{
    "Basic OP Mode Iterative": {
        "prefix": "basicIterativeOPMode",
        "body": ["@TeleOp(name=\"$1\", group=\"$2\")",
        "public class $3 extends OpMode",
        "{",
        "    // Declare OpMode members.",
        "    private ElapsedTime runtime = new ElapsedTime();",
        "    private DcMotor leftDrive = null;",
         "   private DcMotor rightDrive = null;",
        "",
         "   /*",
         "    * Code to run ONCE when the driver hits INIT",
         "    */",
         "   @Override",
         "   public void init() {",
         "       telemetry.addData(\"Status\", \"Initialized\");",
        "",
         "       // Initialize the hardware variables. Note that the strings used here as parameters",
         "       // to 'get' must correspond to the names assigned during the robot configuration",
         "       // step (using the FTC Robot Controller app on the phone).",
         "       leftDrive  = hardwareMap.get(DcMotor.class, \"$4\");",
         "       rightDrive = hardwareMap.get(DcMotor.class, \"$5\");",
        "",
         "       // Most robots need the motor on one side to be reversed to drive forward",
         "       // Reverse the motor that runs backwards when connected directly to the battery",
         "       leftDrive.setDirection(DcMotor.Direction.FORWARD);",
         "       rightDrive.setDirection(DcMotor.Direction.REVERSE);",
        "",
         "       // Tell the driver that initialization is complete.",
         "       telemetry.addData(\"Status\", \"Initialized\");",
         "   }",
        "",
         "   /*",
         "    * Code to run REPEATEDLY after the driver hits INIT, but before they hit PLAY",
         "    */",
         "   @Override",
         "   public void init_loop() {",
         "   }",
        "",
         "   /*",
         "    * Code to run ONCE when the driver hits PLAY",
         "    */",
         "   @Override",
         "   public void start() {",
         "       runtime.reset();",
         "   }",
        "",
         "   /*",
         "    * Code to run REPEATEDLY after the driver hits PLAY but before they hit STOP",
         "    */",
         "   @Override",
         "   public void loop() {",
         "       // Setup a variable for each drive wheel to save power level for telemetry",
         "       double leftPower;",
         "       double rightPower;",
        "",
         "       // Choose to drive using either Tank Mode, or POV Mode",
         "       // Comment out the method that's not used.  The default below is POV.",
        "",
         "       // POV Mode uses left stick to go forward, and right stick to turn.",
         "       // - This uses basic math to combine motions and is easier to drive straight.",
         "       double drive = -gamepad1.left_stick_y;",
         "       double turn  =  gamepad1.right_stick_x;",
         "       leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
         "       rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
        "",
         "       // Tank Mode uses one stick to control each wheel.",
         "       // - This requires no math, but it is hard to drive forward slowly and keep straight.",
         "       // leftPower  = -gamepad1.left_stick_y ;",
         "       // rightPower = -gamepad1.right_stick_y ;",
        "",
         "       // Send calculated power to wheels",
         "       leftDrive.setPower(leftPower);",
         "       rightDrive.setPower(rightPower);",
        "",
         "       // Show the elapsed game time and wheel power.",
         "       telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());",
         "       telemetry.addData(\"Motors\", \"left (%.2f), right (%.2f)\", leftPower, rightPower);",
         "   }",
        "",
         "   /*",
         "    * Code to run ONCE after the driver hits STOP",
         "    */",
         "   @Override",
         "   public void stop() {",
         "   }",
        "",
        "}"],
        "description": "This snippet contains an example of an iterative (Non-Linear) \"OpMode\".\nAn OpMode is a 'program' that runs in either the autonomous or the teleop period of an FTC match.\nThe names of OpModes appear on the menu of the FTC Driver Station.\nWhen an selection is made from the menu, the corresponding OpMode\nclass is instantiated on the Robot Controller and executed.\n\nThis particular OpMode just executes a basic Tank Drive Teleop for a two wheeled robot\nIt includes all the skeletal structure that all iterative OpModes contain."
    },
    "Basic OP Mode Linear": {
        "prefix": "basicLinearOPMode",
        "description": "This file contains an minimal example of a Linear \"OpMode\". An OpMode is a 'program' that runs in either\nthe autonomous or the teleop period of an FTC match. The names of OpModes appear on the menu\nof the FTC Driver Station. When an selection is made from the menu, the corresponding OpMode\nclass is instantiated on the Robot Controller and executed.\n\nThis particular OpMode just executes a basic Tank Drive Teleop for a two wheeled robot\nIt includes all the skeletal structure that all linear OpModes contain.",
        "body": ["@TeleOp(name=\"Basic: Linear OpMode\", group=\"Linear Opmode\")",
        "public class BasicOpMode_Linear extends LinearOpMode {",
        "",
        "    // Declare OpMode members.",
        "    private ElapsedTime runtime = new ElapsedTime();",
        "    private DcMotor leftDrive = null;",
        "    private DcMotor rightDrive = null;",
        "",
        "    @Override",
        "    public void runOpMode() {",
        "        telemetry.addData(\"Status\", \"Initialized\");",
        "        telemetry.update();",
        "",
        "        // Initialize the hardware variables. Note that the strings used here as parameters",
        "        // to 'get' must correspond to the names assigned during the robot configuration",
        "        // step (using the FTC Robot Controller app on the phone).",
        "        leftDrive  = hardwareMap.get(DcMotor.class, \"left_drive\");",
        "        rightDrive = hardwareMap.get(DcMotor.class, \"right_drive\");",
        "",
        "        // Most robots need the motor on one side to be reversed to drive forward",
        "        // Reverse the motor that runs backwards when connected directly to the battery",
        "        leftDrive.setDirection(DcMotor.Direction.FORWARD);",
        "        rightDrive.setDirection(DcMotor.Direction.REVERSE);",
        "",
        "        // Wait for the game to start (driver presses PLAY)",
        "        waitForStart();",
        "        runtime.reset();",
        "",
        "        // run until the end of the match (driver presses STOP)",
        "        while (opModeIsActive()) {",
        "",
        "            // Setup a variable for each drive wheel to save power level for telemetry",
        "            double leftPower;",
        "            double rightPower;",
        "",
        "            // Choose to drive using either Tank Mode, or POV Mode",
        "            // Comment out the method that's not used.  The default below is POV.",
        "",
        "            // POV Mode uses left stick to go forward, and right stick to turn.",
        "            // - This uses basic math to combine motions and is easier to drive straight.",
        "            double drive = -gamepad1.left_stick_y;",
        "            double turn  =  gamepad1.right_stick_x;",
        "            leftPower    = Range.clip(drive + turn, -1.0, 1.0) ;",
        "            rightPower   = Range.clip(drive - turn, -1.0, 1.0) ;",
        "",
        "            // Tank Mode uses one stick to control each wheel.",
        "            // - This requires no math, but it is hard to drive forward slowly and keep straight.",
        "            // leftPower  = -gamepad1.left_stick_y ;",
        "            // rightPower = -gamepad1.right_stick_y ;",
        "",
        "            // Send calculated power to wheels",
        "            leftDrive.setPower(leftPower);",
        "            rightDrive.setPower(rightPower);",
        "",
        "            // Show the elapsed game time and wheel power.",
        "            telemetry.addData(\"Status\", \"Run Time: \" + runtime.toString());",
        "            telemetry.addData(\"Motors\", \"left (%.2f), right (%.2f)\", leftPower, rightPower);",
        "            telemetry.update();",
        "        }",
        "    }",
        "}"]
    },
    "Concept Compass Calibration": {
        "prefix": "conceptCompassCalibration",
        "description": "This file illustrates the concept of calibrating a MR Compass\nIt uses the common Pushbot hardware class to define the drive on the robot.\nThe code is structured as a LinearOpMode\n\nThis code assumes there is a compass configured with the name \"compass\"\n\nThis code will put the compass into calibration mode, wait three seconds and then attempt\nto rotate two full turns clockwise.  This will allow the compass to do a magnetic calibration.\n\n Once compete, the program will put the compass back into measurement mode and check to see if the\n calibration was successful.",
        "body": ["@TeleOp(name=\"Concept: Compass Calibration\", group=\"Concept\")",
        "public class ConceptCompassCalibration extends LinearOpMode {",
        "",
        "    /* Declare OpMode members. */",
        "    HardwarePushbot     robot   = new HardwarePushbot();   // Use a Pushbot's hardware",
        "    private ElapsedTime runtime = new ElapsedTime();",
        "    CompassSensor       compass;",
        "",
        "    final static double     MOTOR_POWER   = 0.2; // scale from 0 to 1",
        "    static final long       HOLD_TIME_MS  = 3000;",
        "    static final double     CAL_TIME_SEC  = 20;",
        "",
        "    @Override",
        "    public void runOpMode() {",
        "",
        "        /* Initialize the drive system variables.",
        "         * The init() method of the hardware class does all the work here",
        "         */",
        "        robot.init(hardwareMap);",
        "",
        "        // get a reference to our Compass Sensor object.",
        "        compass = hardwareMap.get(CompassSensor.class, \"compass\");",
        "",
        "        // Send telemetry message to signify robot waiting;",
        "        telemetry.addData(\"Status\", \"Ready to cal\");    //",
        "        telemetry.update();",
        "",
        "        // Wait for the game to start (driver presses PLAY)",
        "        waitForStart();",
        "",
        "        // Set the compass to calibration mode",
        "        compass.setMode(CompassSensor.CompassMode.CALIBRATION_MODE);",
        "        telemetry.addData(\"Compass\", \"Compass in calibration mode\");",
        "        telemetry.update();",
        "",
        "        sleep(HOLD_TIME_MS);  // Just do a sleep while we switch modes",
        "",
        "        // Start the robot rotating clockwise",
        "        telemetry.addData(\"Compass\", \"Calibration mode. Turning the robot...\");",
        "        telemetry.update();",
        "        robot.leftDrive.setPower(MOTOR_POWER);",
        "        robot.rightDrive.setPower(-MOTOR_POWER);",
        "",
        "        // run until time expires OR the driver presses STOP;",
        "        runtime.reset();",
        "        while (opModeIsActive() && (runtime.time() < CAL_TIME_SEC)) {",
        "            idle();",
        "        }",
        "",
        "        // Stop all motors and turn off claibration",
        "        robot.leftDrive.setPower(0);",
        "        robot.rightDrive.setPower(0);",
        "        compass.setMode(CompassSensor.CompassMode.MEASUREMENT_MODE);",
        "        telemetry.addData(\"Compass\", \"Returning to measurement mode\");",
        "        telemetry.update();",
        "",
        "        sleep(HOLD_TIME_MS);  // Just do a sleep while we switch modes",
        "",
        "        // Report whether the Calibration was successful or not.",
        "        if (compass.calibrationFailed())",
        "            telemetry.addData(\"Compass\", \"Calibrate Failed. Try Again!\");",
        "        else",
        "            telemetry.addData(\"Compass\", \"Calibrate Passed.\");",
        "        telemetry.update();",
        "    }",
        "}"]
    },
    "Concept DIM As Indicator": {
        "prefix": "conceptDIMAsIndicator",
        "description": "This OpMode illustrates using the Device Interface Module as a signalling device.\nThe code is structured as a LinearOpMode\n\nThis code assumes a DIM name \"dim\".\n\nThere are many examples where the robot might like to signal the driver, without requiring them\nto look at the driver station.  This might be something like a \"ball in hopper\" condition or a\n\"ready to shoot\" condition.\n\nThe DIM has two user settable indicator LEDs (one red one blue).  These can be controlled\ndirectly from your program.\n\nUse Android Studios to Copy this Class, and Paste it into your team's code folder with a new name.\nRemove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list",
        "body": ["@TeleOp(name = \"Concept: DIM As Indicator\", group = \"Concept\")",
        "public class ConceptDIMAsIndicator extends LinearOpMode {",
        "",
        "    static final int    BLUE_LED    = 0;     // Blue LED channel on DIM",
        "    static final int    RED_LED     = 1;     // Red LED Channel on DIM",
        "",
        "    // Create timer to toggle LEDs",
        "    private ElapsedTime runtime = new ElapsedTime();",
        "",
        "    // Define class members",
        "    DeviceInterfaceModule   dim;",
        "",
        "    @Override",
        "    public void runOpMode() {",
        "",
        "        // Connect to motor (Assume standard left wheel)",
        "        // Change the text in quotes to match any motor name on your robot.",
        "        dim = hardwareMap.get(DeviceInterfaceModule.class, \"dim\");",
        "",
        "        // Toggle LEDs while Waiting for the start button",
        "        telemetry.addData(\">\", \"Press Play to test LEDs.\" );",
        "        telemetry.update();",
        "",
        "        while (!isStarted()) {",
        "            // Determine if we are on an odd or even second",
        "            boolean even = (((int)(runtime.time()) & 0x01) == 0);",
        "            dim.setLED(RED_LED,   even); // Red for even",
        "            dim.setLED(BLUE_LED, !even); // Blue for odd",
        "            idle();",
        "        }",
        "",
        "        // Running now",
        "        telemetry.addData(\">\", \"Press X for Blue, B for Red.\" );",
        "        telemetry.update();",
        "",
        "        // Now just use red and blue buttons to set red and blue LEDs",
        "        while(opModeIsActive()){",
        "            dim.setLED(BLUE_LED, gamepad1.x);",
        "            dim.setLED(RED_LED,  gamepad1.b);",
        "            idle();",
        "        }",
        "",
        "        // Turn off LEDs;",
        "        dim.setLED(BLUE_LED, false);",
        "        dim.setLED(RED_LED,  false);",
        "        telemetry.addData(\">\", \"Done\");",
        "        telemetry.update();",
        "    }",
        "}"]
    }
}